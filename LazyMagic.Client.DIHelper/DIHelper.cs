
using System.Reflection;

namespace LazyMagic.Client.DIHelper;
// Register services having specified Interfaces
// Example:
// namespace MyNamespace;
// public class YadaViewModel : LzItemViewModelBase<Yada, YadaModel>, IYadaViewModel
// {
// }

[Generator]
public class DIHelper : ISourceGenerator
{
    static string[] InterfaceTargets = { "ILzTransient", "ILzSingleton", "ILzScoped" };
    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        
        Log(context, "DIHelper.Execute");
        var namespaceName = context.Compilation.AssemblyName!; 
        Log(context, $"AssemblyName: {namespaceName}");
        List<(string, string, string)> interfaces = new(); // scope, interface, class
        try
        {
            foreach (var syntaxTree in context.Compilation.SyntaxTrees)
            {
                var model = context.Compilation.GetSemanticModel(syntaxTree);
                    
                // The following query to get derived classes is fragile. However, the alternative use of semantic 
                // analysis to find derived classes proved difficult to implement and seems to be overkill for this
                // use case.
                var derivedClasses = syntaxTree.GetRoot()
                    .DescendantNodes()
                    .OfType<ClassDeclarationSyntax>()
                    .Where(cds => cds.BaseList?.Types.Any(b => b.Type is IdentifierNameSyntax ins && InterfaceTargets.Contains( ins.Identifier.Text)) == true);

                //Log(context, $"derivedClasses: {derivedClasses.Count()}");
                
                if (derivedClasses != null && derivedClasses.Count() > 0)
                    foreach (var derivedClass in derivedClasses)
                        interfaces.Add((
                            GetScope(derivedClass),
                            "I" + derivedClass.Identifier.Text, 
                            derivedClass.Identifier.Text));


            }
            if(interfaces.Count > 0)
            {
                var source = GenerateClassModelSource(namespaceName, interfaces);
                Log(context, $"source: {source}");
                context.AddSource($"DIHelper.g.cs", source);

            }


        } catch (Exception ex)
        {
            var diagnostic = Diagnostic.Create(_messageRule, Location.None, ex.Message + "01");
            context.ReportDiagnostic(diagnostic);
        }   
    }
    private static string GetScope(ClassDeclarationSyntax classNode)
    {
        foreach(var iface in classNode.BaseList?.Types!)
            if(iface.Type is IdentifierNameSyntax ins && InterfaceTargets.Contains( ins.Identifier.Text))
                switch(ins.Identifier.Text)
                {
                    case "ILzTransient": return "Transient";
                    case "ILzSingleton": return "Singleton";
                    case "ILzScoped": return "Scoped";
                }
        throw new Exception("No scope found");
    }
    private static SourceText GenerateClassModelSource(string namespaceName, List<(string scope, string interfaceName, string className)> intefaces)
    {
        //Log(context, $"GenerateClassModelSource: {namespaceName} {modelType}");
        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine(@$"
// <auto-generated />
namespace {namespaceName};
public static class DIHelper 
{{
    public static void RegisterServices(IServiceCollection services)
    {{
");

        foreach(var iface in intefaces)
            sourceBuilder.AppendLine($"        services.TryAdd{iface.scope}<{iface.interfaceName},{iface.className}>();");

        sourceBuilder.AppendLine($@"
    }}
}}");
        SyntaxTree tree = CSharpSyntaxTree.ParseText(sourceBuilder.ToString());
        SyntaxNode root = tree.GetRoot();
        SyntaxNode formattedRoot = root.NormalizeWhitespace();
        return SourceText.From(formattedRoot.ToString(), Encoding.UTF8);
    }

    private static readonly DiagnosticDescriptor _messageRule = new(
        id: "LZI0002",
        title: "LazyMagic.LzItemViewModelGenerator Source Generator Message",
        messageFormat: "{0}",
        category: "SourceGenerator",
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true);
    private static void Log(GeneratorExecutionContext context, string? message)
    {
        if (message == null) return;
        string[] lines = message.Split(new[] { '\n' }, StringSplitOptions.None);
        foreach (var line in lines)
        {
            var diagnostic = Diagnostic.Create(_messageRule, Location.None, line);
            context.ReportDiagnostic(diagnostic);
        }
    }
}